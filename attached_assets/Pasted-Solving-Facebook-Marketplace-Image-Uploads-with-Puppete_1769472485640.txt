Solving Facebook Marketplace Image Uploads with Puppeteer and Browserless
Why your current uploadFile() approach fails
Your diagnosis is correct: ElementHandle.uploadFile() (and any wrapper around it) ultimately relies on Chrome DevTools Protocol (CDP) to set the <input type="file"> element’s selected files using file paths on the machine where Chrome is running. In CDP, the primitive for this is DOM.setFileInputFiles, whose files parameter is explicitly an array of file paths. 
1

That’s why things work in “local Puppeteer” (Node + Chrome share a filesystem), but break in your architecture:

Your Node process (Replit) downloads images to /tmp/....
Your Chrome instance is remote (Browserless), so /tmp/... on Replit does not exist on Browserless’ host.
When Puppeteer calls uploadFile() across a puppeteer.connect() session, missing paths can lead to “silent” failures. A long-standing Puppeteer issue documents this exact behavior: when the file doesn’t exist on the remote host, Puppeteer can “silently upload an empty payload” and there’s “no possible workaround except uploading the file to remote puppeteer’s host.” 
2
Puppeteer’s own “Files” guide reinforces that file uploads are normally done by locating a file input and calling ElementHandle.uploadFile with a local path. 
3
Browserless’ own documentation calls this out and provides the key workaround you need: for remote sessions, you can upload client-side data by creating “virtual files” in the page using page.evaluate() with File + DataTransfer, then dispatching a change event. 
4

Approach analysis against Facebook Marketplace
Below is a pragmatic evaluation of the approaches you listed, specifically in the context of Facebook Marketplace’s vehicle listing uploader (React-based UI with a hidden <input type="file" multiple accept=...>). A Stack Overflow answer that inspected Marketplace’s uploader shows the input is indeed present and looks like a normal multiple file input with a broad accept string (images + some videos). 
5

Direct uploadFile() with local temp paths
This will not work in your Replit → Browserless split because CDP requires paths on the Chrome host (DOM.setFileInputFiles takes file paths). 
1

Base64/DataURL → File injection via page.evaluate() + DataTransfer
This is the most directly applicable fix for Browserless-connected Puppeteer because it avoids the remote filesystem entirely and instead constructs a real File object in the page context and assigns it to the input using a DataTransfer. Browserless explicitly documents this technique as the workaround for uploading “client-side data.” 
4

Key risk: some apps may ignore synthetic events if they rely heavily on event.isTrusted. Your note about isTrusted is valid; dispatchEvent() creates untrusted events. However, many React uploaders still process change events as long as target.files contains File objects (because legitimate drag/drop and picker flows converge on “here are File objects”). Browserless wouldn’t recommend this approach if it only worked rarely. 
4

DataTransfer API + programmatic drag-and-drop events
This can work on some uploaders, but it is usually not better than setting input.files and firing change, because:

You still need File objects (same “make virtual files” problem).
Synthetic drag/drop events are also not trusted, so if Facebook is checking trust, this doesn’t intrinsically solve it.
It’s more brittle because you must hit Facebook’s specific drop target node(s) and event sequence.
“CDP file interception / streaming bytes into the chooser”
There is no standard CDP command that sets file-input bytes directly; CDP’s file-input mechanism is filepath-based (DOM.setFileInputFiles). 
1

So “CDP interception” only helps if you can first place files on the remote Chrome filesystem (or run the automation where Chrome’s filesystem is accessible).

Browserless-specific “file upload API”
For Browserless BaaS (your puppeteer.connect() usage), the official Browserless documentation steers you toward the DataTransfer virtual-file approach for “client-side data,” implying there isn’t a general “upload file into the container then reference a path” feature in this flow. 
4

Browserless does offer a separate Function API (execute Puppeteer code via HTTP) that runs your code in Browserless’ environment. 
6
 This can be leveraged as a fallback architecture: download images there, then uploadFile() using paths that exist there.

Recommended solution
Use virtual file creation in the browser context (Browserless-recommended) by:

Download each image URL on your Node server into a Buffer (no disk required).
Convert to base64 (or chunk to manage memory).
In page.evaluate():
Convert base64 back to bytes (Uint8Array).
Create real File objects: new File([bytes], name, { type: mimeType }).
Add them to a DataTransfer.
Assign input.files = dataTransfer.files.
Dispatch input + change events (bubbling) so React sees it.
This is precisely the workaround Browserless documents for remote upload scenarios. 
4

And Facebook Marketplace’s uploader is ultimately backed by an <input type="file" multiple ...> element, so populating that input with real File objects is aligned with how the UI is built. 
5

Complete production-ready TypeScript code
This function is designed to replace the broken uploadFile(...downloadedImages) call. It accepts image URLs, respects Facebook’s “up to 20” constraint, avoids remote filesystem assumptions, uploads in batches to reduce giant CDP payloads, and includes robust error reporting.

ts
Copy
import type { Page } from "puppeteer"; // works with puppeteer or puppeteer-core
import crypto from "node:crypto";

/**
 * Tunables for reliability across remote (Browserless) sessions.
 */
export interface FacebookMarketplaceImageUploadOptions {
  /**
   * Facebook Marketplace allows up to 20 photos per listing (typical UI limit).
   * Default: 20
   */
  maxImages?: number;

  /**
   * How many images to inject per page.evaluate call.
   * Smaller batches reduce WebSocket payload size and JS heap spikes in the page.
   * Default: 4
   */
  batchSize?: number;

  /**
   * Timeout for waiting for the file input to appear.
   * Default: 30_000
   */
  waitForInputTimeoutMs?: number;

  /**
   * Per-image network timeout for downloading the image in Node.
   * Default: 25_000
   */
  perImageDownloadTimeoutMs?: number;

  /**
   * Maximum allowed bytes for a single image download.
   * Prevents runaway memory usage on very large images.
   * Default: 15 * 1024 * 1024 (15MB)
   */
  maxImageBytes?: number;

  /**
   * Optional override if you have a known selector for the marketplace file input.
   * If omitted, we look for the best input[type=file] heuristic on the page.
   */
  fileInputSelector?: string;

  /**
   * Prefix for generated filenames (Facebook uses filename mainly for display/logging).
   * Default: "vehicle"
   */
  fileNamePrefix?: string;

  /**
   * Extra headers for fetching images (if your inventory requires auth headers).
   * Note: If images require cookies, consider proxying them or embedding signed URLs.
   */
  fetchHeaders?: Record<string, string>;

  /**
   * Enable verbose console logging from Node side.
   */
  debug?: boolean;
}

export interface FacebookMarketplaceImageUploadResult {
  attempted: number;
  uploaded: number; // number of images successfully passed into the page injection routine
  failures: Array<{ url: string; reason: string }>;
}

/**
 * Upload vehicle images (URLs) to Facebook Marketplace while connected to remote Chrome (Browserless).
 *
 * Core idea:
 * - download bytes in Node
 * - send base64 bytes to the page
 * - construct File objects inside the page and assign them to the <input type=file> using DataTransfer
 *
 * This avoids the remote filesystem mismatch that breaks ElementHandle.uploadFile() over puppeteer.connect.
 * Browserless documents this "virtual file" workaround for remote uploads.  citeturn1view0
 */
export async function uploadMarketplaceImagesFromUrls(
  page: Page,
  imageUrls: string[],
  opts: FacebookMarketplaceImageUploadOptions = {}
): Promise<FacebookMarketplaceImageUploadResult> {
  const {
    maxImages = 20,
    batchSize = 4,
    waitForInputTimeoutMs = 30_000,
    perImageDownloadTimeoutMs = 25_000,
    maxImageBytes = 15 * 1024 * 1024,
    fileInputSelector,
    fileNamePrefix = "vehicle",
    fetchHeaders,
    debug = false,
  } = opts;

  const urls = (imageUrls ?? []).filter(Boolean).slice(0, maxImages);
  const failures: Array<{ url: string; reason: string }> = [];

  if (urls.length === 0) {
    return { attempted: 0, uploaded: 0, failures: [] };
  }

  // Ensure the marketplace uploader exists.
  // We intentionally do NOT require "visible: true" because FB often hides the input and uses a styled dropzone.
  await page.waitForSelector(fileInputSelector ?? 'input[type="file"]', {
    timeout: waitForInputTimeoutMs,
  });

  type FileDescriptor = {
    name: string;
    mimeType: string;
    base64Data: string;
  };

  const pending: FileDescriptor[] = [];
  let uploaded = 0;

  for (let i = 0; i < urls.length; i++) {
    const url = urls[i];

    try {
      const { buffer, mimeType } = await downloadImageToBuffer(url, {
        timeoutMs: perImageDownloadTimeoutMs,
        maxBytes: maxImageBytes,
        headers: fetchHeaders,
      });

      const safeMime = mimeType || guessImageMimeFromUrl(url) || "image/jpeg";
      const ext = guessExtensionFromMime(safeMime) || guessExtensionFromUrl(url) || "jpg";

      const name = `${fileNamePrefix}-${String(i).padStart(2, "0")}-${crypto
        .randomUUID()
        .slice(0, 8)}.${ext}`;

      const base64Data = buffer.toString("base64");

      pending.push({ name, mimeType: safeMime, base64Data });

      // Flush in batches to avoid huge page.evaluate payloads.
      const isLast = i === urls.length - 1;
      if (pending.length >= batchSize || isLast) {
        const batch = pending.splice(0, pending.length);

        // Inject into the page.
        const injectResult = await injectFilesIntoMarketplaceFileInput(page, batch, {
          selector: fileInputSelector,
        });

        if (debug) {
          // eslint-disable-next-line no-console
          console.log("[fb-upload] injected batch:", {
            batchCount: batch.length,
            pageReportedInputFileCount: injectResult.inputFileCount,
            usedSelector: injectResult.usedSelector,
            usedHeuristic: injectResult.usedHeuristic,
          });
        }

        uploaded += batch.length;

        // Give FB’s uploader a moment to start processing (thumbnail + upload requests).
        // This is intentionally small; most robustness should come from waits in your later steps.
        await page.waitForTimeout(350);
      }
    } catch (err: any) {
      const reason = err?.message ? String(err.message) : String(err);
      failures.push({ url, reason });
      if (debug) {
        // eslint-disable-next-line no-console
        console.warn("[fb-upload] failed to prepare image:", url, reason);
      }
    }
  }

  return { attempted: urls.length, uploaded, failures };
}

/**
 * Downloads an image URL into memory (Buffer) with basic size + timeout protection.
 */
async function downloadImageToBuffer(
  url: string,
  params: {
    timeoutMs: number;
    maxBytes: number;
    headers?: Record<string, string>;
  }
): Promise<{ buffer: Buffer; mimeType: string | null }> {
  const { timeoutMs, maxBytes, headers } = params;

  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);

  try {
    // Node 18+ has global fetch. If your runtime lacks it, install undici/node-fetch and polyfill.
    const res = await fetch(url, {
      method: "GET",
      headers,
      signal: controller.signal,
      redirect: "follow",
    });

    if (!res.ok) {
      throw new Error(`Image download failed: ${res.status} ${res.statusText}`);
    }

    const contentType = res.headers.get("content-type");
    const mimeType = contentType ? contentType.split(";")[0].trim() : null;

    // If Content-Length exists, enforce early.
    const lengthHeader = res.headers.get("content-length");
    if (lengthHeader) {
      const n = Number(lengthHeader);
      if (Number.isFinite(n) && n > maxBytes) {
        throw new Error(`Image too large: content-length=${n} bytes (limit=${maxBytes})`);
      }
    }

    const ab = await res.arrayBuffer();
    const buffer = Buffer.from(ab);

    if (buffer.length > maxBytes) {
      throw new Error(`Image too large after download: ${buffer.length} bytes (limit=${maxBytes})`);
    }

    return { buffer, mimeType };
  } catch (e: any) {
    if (e?.name === "AbortError") {
      throw new Error(`Image download timeout after ${timeoutMs}ms`);
    }
    throw e;
  } finally {
    clearTimeout(t);
  }
}

/**
 * Injects a batch of base64 images into FB's <input type=file> using DataTransfer + File objects.
 * Browserless documents this approach for remote uploads. citeturn1view0
 */
async function injectFilesIntoMarketplaceFileInput(
  page: Page,
  files: Array<{ name: string; mimeType: string; base64Data: string }>,
  params: { selector?: string }
): Promise<{ inputFileCount: number; usedSelector: string | null; usedHeuristic: boolean }> {
  const { selector } = params;

  return await page.evaluate(
    ({ selector, files }) => {
      function b64ToUint8Array(base64: string): Uint8Array {
        // Same core technique as Browserless' documented workaround:
        // atob -> Uint8Array. citeturn1view0
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
      }

      function scoreInput(input: HTMLInputElement): number {
        // Heuristic scoring to pick the Marketplace uploader input when selector isn't provided.
        // Marketplace's uploader typically uses multiple + accept containing images. citeturn5view0
        let score = 0;
        const accept = (input.getAttribute("accept") || "").toLowerCase();
        if (accept.includes("image")) score += 10;
        if (input.multiple) score += 5;
        if (accept.includes("video")) score += 1;
        // Favor inputs that are in the DOM and not disabled.
        if (!input.disabled) score += 1;
        if (input.isConnected) score += 1;
        return score;
      }

      function findBestFileInput(): HTMLInputElement | null {
        const inputs = Array.from(document.querySelectorAll('input[type="file"]')) as HTMLInputElement[];
        if (inputs.length === 0) return null;
        inputs.sort((a, b) => scoreInput(b) - scoreInput(a));
        return inputs[0] ?? null;
      }

      const input: HTMLInputElement | null =
        (selector ? (document.querySelector(selector) as HTMLInputElement | null) : null) || findBestFileInput();

      if (!input) {
        throw new Error("No <input type=file> found on the page (Marketplace uploader not mounted?)");
      }

      const dt = new DataTransfer();

      for (const f of files) {
        const bytes = b64ToUint8Array(f.base64Data);
        const file = new File([bytes], f.name, { type: f.mimeType, lastModified: Date.now() });
        dt.items.add(file);
      }

      // Assign and notify React.
      // DataTransfer.files is a FileList. citeturn9search4turn9search1
      input.files = dt.files;

      // React commonly listens for change on file inputs; we fire both input and change to be safe.
      input.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
      input.dispatchEvent(new Event("change", { bubbles: true, composed: true }));

      return {
        inputFileCount: input.files ? input.files.length : 0,
        usedSelector: selector ?? null,
        usedHeuristic: !selector,
      };
    },
    { selector: selector ?? null, files }
  );
}

function guessExtensionFromMime(mimeType: string): string | null {
  const mt = mimeType.toLowerCase();
  if (mt === "image/jpeg" || mt === "image/jpg") return "jpg";
  if (mt === "image/png") return "png";
  if (mt === "image/webp") return "webp";
  if (mt === "image/gif") return "gif";
  if (mt === "image/heic") return "heic";
  if (mt === "image/heif") return "heif";
  return null;
}

function guessExtensionFromUrl(url: string): string | null {
  try {
    const u = new URL(url);
    const path = u.pathname.toLowerCase();
    const m = path.match(/\.([a-z0-9]{2,5})$/);
    return m?.[1] ?? null;
  } catch {
    return null;
  }
}

function guessImageMimeFromUrl(url: string): string | null {
  const ext = guessExtensionFromUrl(url);
  if (!ext) return null;
  switch (ext) {
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "gif":
      return "image/gif";
    case "heic":
      return "image/heic";
    case "heif":
      return "image/heif";
    default:
      return null;
  }
}
How to use it in your flow
Replace your current broken section:

ts
Copy
const fileInput = await page.waitForSelector('input[type="file"][accept*="image"]');
await fileInput.uploadFile(...downloadedImages);
With:

ts
Copy
const result = await uploadMarketplaceImagesFromUrls(page, data.imageUrls, {
  maxImages: 20,
  batchSize: 4, // increase if your images are small; decrease if you see websocket payload issues
  debug: true,
});

// Optional: fail hard if anything didn’t prep/upload
if (result.failures.length) {
  throw new Error(
    `Failed to prepare ${result.failures.length} images: ` +
      result.failures.map(f => `${f.url} -> ${f.reason}`).join("; ")
  );
}
Fallback options if Facebook rejects the primary method
Run the automation inside Browserless via the Function API so real file paths exist
If Facebook Marketplace ever starts hard-gating uploads on trusted picker events, your strongest fallback is to move “download images + uploadFile(paths)” into a runtime co-located with Chrome.

Browserless provides a Function API endpoint that executes custom Puppeteer code via HTTP requests: “Your function receives a page object … and optional context data.” 
6

When your code runs there, you can download images to /tmp on the Browserless worker and then use ElementHandle.uploadFile() with those paths (which aligns with Puppeteer’s documented normal file upload approach). 
3

This is a bigger architectural change (you’d invoke Browserless via REST instead of driving it from Replit over WS), but it is the best way to get “native-like” upload flows when a site is extremely strict.

Reduce CDP payload size by proxying images and fetching them in the page
If your images are large (or you hit WebSocket/frame size limits), avoid sending base64 over CDP by having the page fetch the bytes from a CORS-enabled endpoint you control.

Your Replit server can expose /image-proxy?url=... that fetches the image server-side and returns it with Access-Control-Allow-Origin: *.
In page.evaluate(), fetch the proxy URL, await res.arrayBuffer(), create File, then DataTransfer.
This keeps the heavy bytes transfer on normal HTTP between Browserless Chrome and your server rather than through the Puppeteer CDP pipe. It also bypasses third-party CORS restrictions because your proxy can set permissive CORS headers.

Drag-and-drop simulation as a last resort
If Facebook’s uploader is wired to drop events rather than input change (less likely given the presence of the file input), you can dispatch DragEvent("drop") with dataTransfer.files. Be aware this is generally more brittle and still produces untrusted events, so it is not automatically better than the input approach.

Closing notes on the security constraints you listed
The core, non-negotiable limitation is that CDP’s file-input primitive is path-based (DOM.setFileInputFiles takes file paths). 
1
 That’s what makes your current /tmp/... approach fundamentally incompatible with remote Chrome.
The Browserless-documented virtual file workaround exists specifically to address this remote-upload gap. 
4
Puppeteer’s own issue tracker confirms that uploadFile() over puppeteer.connect() can fail silently when the file doesn’t exist on the remote host. 
2
This solution directly addresses those realities while staying within your constraints (Browserless required, no Facebook API, up to 20 images, remote Chrome).