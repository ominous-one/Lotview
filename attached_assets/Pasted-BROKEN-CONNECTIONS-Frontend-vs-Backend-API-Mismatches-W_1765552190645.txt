BROKEN CONNECTIONS
	•	Frontend vs Backend API Mismatches: We identified a few places where the frontend expects an endpoint or data shape that the backend doesn’t provide. For example, the frontend calls /api/lead/delete?id=XYZ (perhaps from an older version), but the backend defines the route as /api/leads/:id/delete (different path/verb). These result in 404 errors when triggered. All frontend API calls should be cross-verified with backend route definitions. A thorough sweep and testing of each UI action is needed to catch such mismatches.
	•	Missing Feedback on Async Operations: When a user initiates an action like “Sync Inventory to Facebook”, the request is sent to the backend but the UI doesn’t show the result (the button just goes back to enabled state). If the backend fails or succeeds, the user is left uncertain. This broken feedback loop can confuse users – e.g., did their vehicle actually post to Facebook or not? We should implement callbacks or at least notifications in the UI upon success/failure of such operations. Currently, it feels like a broken connection: the action happens (or fails) silently.
	•	Broken Image Links / File Uploads: In the inventory gallery, some image URLs are constructed incorrectly (perhaps missing a base URL or using a localhost path). We saw references to images stored in attached_assets/ that the client attempts to load but cannot find (likely a leftover from development, where images were served from a local folder). This results in broken image icons in the UI. We should fix the image storage path – possibly by uploading images to cloud storage or ensuring the Node static file serving is configured for the upload directory. At the very least, remove or update references to attached_assets if it’s not used.
	•	Email Notification Hookups: The platform code includes an email utility (for example, sending a welcome email or alert), but during testing those emails never arrive. It appears the SMTP configuration is incomplete or incorrect. Essentially, the connection to the email service is broken – there’s no log of attempt or the credentials might be dummy. If email features are meant to be live (password reset, lead notifications, etc.), this needs fixing. If they’re not implemented yet, those code paths should be disabled to avoid confusion.
	•	GoHighLevel Webhook Reception: We expected that GoHighLevel might send webhooks (for instance, when a lead’s status changes), and our platform would receive them. There is a mention of a /api/gohighlevel/webhook route in the code, but it’s not fully implemented (it might just log and not process the data). This half-implemented webhook endpoint means incoming data from GHL is essentially dropped – a broken connection in the integration. Completing this implementation (and verifying the security, e.g., validating webhook signatures if any) will ensure the two-way sync with GHL actually works.
	•	Incorrect JWT Audience in Frontend: The frontend uses the JWT token but doesn’t include a proper audience or issuer when decoding, and the backend doesn’t set one. This typically isn’t “broken” functionally (the token still authenticates), but it’s a bad practice. If in the future we use a library that expects those fields, things could break. It’s worth aligning the JWT usage: set the aud (audience) claim to the intended domain/app, and have the frontend library check it. Currently it’s just not used, which can be seen as a broken implementation of JWT standards.
	•	API Error Handling not Propagated: In some cases, the backend returns an error (e.g., 500 on a database failure), but the frontend doesn’t display anything because it’s not handling error responses. This is more of a UI bug – for instance, if saving a vehicle fails, the network call might return an error JSON, but the UI code doesn’t have a .catch on the promise, so it does nothing. Users get no feedback. We should audit all fetch/axios calls on the frontend to ensure errors are caught and displayed (even a generic “Operation failed, please try again” would be better than silence). Right now, these silent failures appear as if the button just doesn’t work, which is a broken user experience.
	•	Stale Session Handling: If the JWT token expires or is invalid (e.g., if a user token is manually revoked), the backend correctly rejects requests with 401, but the frontend doesn’t log the user out. It continues to show the dashboard, possibly with old cached data, and actions quietly fail. This broken session state management can confuse users (they’ll click around a seemingly logged-in app, but nothing will actually succeed). We need to detect a 401 response globally (perhaps an interceptor in the frontend) and force a logout + redirect to login when that happens. That will properly reconnect the user’s state with reality.